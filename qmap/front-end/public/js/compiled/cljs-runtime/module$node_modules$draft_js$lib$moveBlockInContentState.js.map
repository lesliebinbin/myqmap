{
"version":3,
"file":"module$node_modules$draft_js$lib$moveBlockInContentState.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/draft-js/lib/moveBlockInContentState.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$draft_js$lib$moveBlockInContentState\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule moveBlockInContentState\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\nvar invariant = require('fbjs/lib/invariant');\n\nvar OrderedMap = Immutable.OrderedMap,\n    List = Immutable.List;\n\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  }\n  // possible values of 'insertionMode' are: 'after', 'before'\n  var isInsertedAfterTarget = insertionMode === 'after';\n\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))\n      });\n    });\n\n    // update old prev\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    });\n\n    // update old next\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    });\n\n    // update new next\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    });\n\n    // update new prev\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    });\n\n    // update new parent\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    });\n\n    // update block\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\n\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);\n\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks['delete'](block.getKey());\n      });\n    });\n  }\n\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n\n  var newBlocks = OrderedMap();\n\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\n\nmodule.exports = moveBlockInContentState;\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","ContentBlockNode","Immutable","getNextDelimiterBlockKey","invariant","OrderedMap","List","transformBlock","key","blockMap","func","block","get","set","updateBlockMapLinks","originalBlockToBeMoved","originalTargetBlock","insertionMode","isExperimentalTreeBlock","isInsertedAfterTarget","originalBlockKey","getKey","originalTargetKey","originalParentKey","getParentKey","originalNextSiblingKey","getNextSiblingKey","originalPrevSiblingKey","getPrevSiblingKey","newParentKey","newNextSiblingKey","newPrevSiblingKey","withMutations","blocks","parentChildrenList","getChildKeys","merge","children","indexOf","nextSibling","prevSibling","newParentChildrenList","targetBlockIndex","insertionIndex","newChildrenArray","toArray","splice","parent","moveBlockInContentState","contentState","blockToBeMoved","targetBlock","NODE_ENV","targetKey","blockKey","getBlockMap","blocksToBeMoved","blockMapWithoutBlocksToBeMoved","nextSiblingKey","nextDelimiterBlockKey","toSeq","skipUntil","takeWhile","isBlockToBeMoved","hasNextSiblingAndIsNotNextSibling","doesNotHaveNextSiblingAndIsNotDelimiter","forEach","push","blocksBefore","takeUntil","v","blocksAfter","skip","slicedBlocks","map","newBlocks","blockBefore","getBlockBefore","concat","toOrderedMap","blockAfter","getBlockAfter","selectionBefore","getSelectionAfter","selectionAfter","anchorKey","focusKey"]
}

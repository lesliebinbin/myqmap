shadow$provide["module$node_modules$draft_js$lib$insertFragmentIntoContentState"]=function(global,process,require,module,exports,shadow$shims){var BlockMapBuilder=require("module$node_modules$draft_js$lib$BlockMapBuilder");var ContentBlockNode=require("module$node_modules$draft_js$lib$ContentBlockNode");var Immutable=require("module$node_modules$immutable$dist$immutable");var insertIntoList=require("module$node_modules$draft_js$lib$insertIntoList");var invariant=require("module$node_modules$fbjs$lib$invariant");
var randomizeBlockMapKeys=require("module$node_modules$draft_js$lib$randomizeBlockMapKeys");var List=Immutable.List;var updateExistingBlock=function updateExistingBlock(contentState,selectionState,blockMap,fragmentBlock,targetKey,targetOffset){var targetBlock=blockMap.get(targetKey);var text=targetBlock.getText();var chars=targetBlock.getCharacterList();var finalKey=targetKey;var finalOffset=targetOffset+fragmentBlock.getText().length;var newBlock=targetBlock.merge({text:text.slice(0,targetOffset)+
fragmentBlock.getText()+text.slice(targetOffset),characterList:insertIntoList(chars,fragmentBlock.getCharacterList(),targetOffset),data:fragmentBlock.getData()});return contentState.merge({blockMap:blockMap.set(targetKey,newBlock),selectionBefore:selectionState,selectionAfter:selectionState.merge({anchorKey:finalKey,anchorOffset:finalOffset,focusKey:finalKey,focusOffset:finalOffset,isBackward:false})})};var updateHead=function updateHead(block,targetOffset,fragment){var text=block.getText();var chars=
block.getCharacterList();var headText=text.slice(0,targetOffset);var headCharacters=chars.slice(0,targetOffset);var appendToHead=fragment.first();return block.merge({text:headText+appendToHead.getText(),characterList:headCharacters.concat(appendToHead.getCharacterList()),type:headText?block.getType():appendToHead.getType(),data:appendToHead.getData()})};var updateTail=function updateTail(block,targetOffset,fragment){var text=block.getText();var chars=block.getCharacterList();var blockSize=text.length;
var tailText=text.slice(targetOffset,blockSize);var tailCharacters=chars.slice(targetOffset,blockSize);var prependToTail=fragment.last();return prependToTail.merge({text:prependToTail.getText()+tailText,characterList:prependToTail.getCharacterList().concat(tailCharacters),data:prependToTail.getData()})};var getRootBlocks=function getRootBlocks(block,blockMap){var headKey=block.getKey();var rootBlock=block;var rootBlocks=[];if(blockMap.get(headKey))rootBlocks.push(headKey);while(rootBlock&&rootBlock.getNextSiblingKey()){var lastSiblingKey=
rootBlock.getNextSiblingKey();if(!lastSiblingKey)break;rootBlocks.push(lastSiblingKey);rootBlock=blockMap.get(lastSiblingKey)}return rootBlocks};var updateBlockMapLinks=function updateBlockMapLinks(blockMap,originalBlockMap,targetBlock,fragmentHeadBlock){return blockMap.withMutations(function(blockMapState){var targetKey=targetBlock.getKey();var headKey=fragmentHeadBlock.getKey();var targetNextKey=targetBlock.getNextSiblingKey();var targetParentKey=targetBlock.getParentKey();var fragmentRootBlocks=
getRootBlocks(fragmentHeadBlock,blockMap);var lastRootFragmentBlockKey=fragmentRootBlocks[fragmentRootBlocks.length-1];if(blockMapState.get(headKey)){blockMapState.setIn([targetKey,"nextSibling"],headKey);blockMapState.setIn([headKey,"prevSibling"],targetKey)}else{blockMapState.setIn([targetKey,"nextSibling"],fragmentHeadBlock.getNextSiblingKey());blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(),"prevSibling"],targetKey)}blockMapState.setIn([lastRootFragmentBlockKey,"nextSibling"],targetNextKey);
if(targetNextKey)blockMapState.setIn([targetNextKey,"prevSibling"],lastRootFragmentBlockKey);fragmentRootBlocks.forEach(function(blockKey){return blockMapState.setIn([blockKey,"parent"],targetParentKey)});if(targetParentKey){var targetParent=blockMap.get(targetParentKey);var originalTargetParentChildKeys=targetParent.getChildKeys();var targetBlockIndex=originalTargetParentChildKeys.indexOf(targetKey);var insertionIndex=targetBlockIndex+1;var newChildrenKeysArray=originalTargetParentChildKeys.toArray();
newChildrenKeysArray.splice.apply(newChildrenKeysArray,[insertionIndex,0].concat(fragmentRootBlocks));blockMapState.setIn([targetParentKey,"children"],List(newChildrenKeysArray))}})};var insertFragment=function insertFragment(contentState,selectionState,blockMap,fragment,targetKey,targetOffset){var isTreeBasedBlockMap=blockMap.first()instanceof ContentBlockNode;var newBlockArr=[];var fragmentSize=fragment.size;var target=blockMap.get(targetKey);var head=fragment.first();var tail=fragment.last();var finalOffset=
tail.getLength();var finalKey=tail.getKey();var shouldNotUpdateFromFragmentBlock=isTreeBasedBlockMap&&(!target.getChildKeys().isEmpty()||!head.getChildKeys().isEmpty());blockMap.forEach(function(block,blockKey){if(blockKey!==targetKey){newBlockArr.push(block);return}if(shouldNotUpdateFromFragmentBlock)newBlockArr.push(block);else newBlockArr.push(updateHead(block,targetOffset,fragment));fragment.slice(shouldNotUpdateFromFragmentBlock?0:1,fragmentSize-1).forEach(function(fragmentBlock){return newBlockArr.push(fragmentBlock)});
newBlockArr.push(updateTail(block,targetOffset,fragment))});var updatedBlockMap=BlockMapBuilder.createFromArray(newBlockArr);if(isTreeBasedBlockMap)updatedBlockMap=updateBlockMapLinks(updatedBlockMap,blockMap,target,head);return contentState.merge({blockMap:updatedBlockMap,selectionBefore:selectionState,selectionAfter:selectionState.merge({anchorKey:finalKey,anchorOffset:finalOffset,focusKey:finalKey,focusOffset:finalOffset,isBackward:false})})};var insertFragmentIntoContentState=function insertFragmentIntoContentState(contentState,
selectionState,fragmentBlockMap){!selectionState.isCollapsed()?"development"!=="production"?invariant(false,"`insertFragment` should only be called with a collapsed selection state."):invariant(false):void 0;var blockMap=contentState.getBlockMap();var fragment=randomizeBlockMapKeys(fragmentBlockMap);var targetKey=selectionState.getStartKey();var targetOffset=selectionState.getStartOffset();var targetBlock=blockMap.get(targetKey);if(targetBlock instanceof ContentBlockNode)!targetBlock.getChildKeys().isEmpty()?
"development"!=="production"?invariant(false,"`insertFragment` should not be called when a container node is selected."):invariant(false):void 0;if(fragment.size===1)return updateExistingBlock(contentState,selectionState,blockMap,fragment.first(),targetKey,targetOffset);return insertFragment(contentState,selectionState,blockMap,fragment,targetKey,targetOffset)};module.exports=insertFragmentIntoContentState}
//# sourceMappingURL=module$node_modules$draft_js$lib$insertFragmentIntoContentState.js.map

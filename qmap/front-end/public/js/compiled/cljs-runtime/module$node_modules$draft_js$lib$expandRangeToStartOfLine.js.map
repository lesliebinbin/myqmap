{
"version":3,
"file":"module$node_modules$draft_js$lib$expandRangeToStartOfLine.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/draft-js/lib/expandRangeToStartOfLine.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$draft_js$lib$expandRangeToStartOfLine\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule expandRangeToStartOfLine\n * @format\n * \n */\n\nvar UnicodeUtils = require('fbjs/lib/UnicodeUtils');\n\nvar getRangeClientRects = require('./getRangeClientRects');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Return the computed line height, in pixels, for the provided element.\n */\nfunction getLineHeightPx(element) {\n  var computed = getComputedStyle(element);\n  var div = document.createElement('div');\n  div.style.fontFamily = computed.fontFamily;\n  div.style.fontSize = computed.fontSize;\n  div.style.fontStyle = computed.fontStyle;\n  div.style.fontWeight = computed.fontWeight;\n  div.style.lineHeight = computed.lineHeight;\n  div.style.position = 'absolute';\n  div.textContent = 'M';\n\n  var documentBody = document.body;\n  !documentBody ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing document.body') : invariant(false) : void 0;\n\n  // forced layout here\n  documentBody.appendChild(div);\n  var rect = div.getBoundingClientRect();\n  documentBody.removeChild(div);\n\n  return rect.height;\n}\n\n/**\n * Return whether every ClientRect in the provided list lies on the same line.\n *\n * We assume that the rects on the same line all contain the baseline, so the\n * lowest top line needs to be above the highest bottom line (i.e., if you were\n * to project the rects onto the y-axis, their intersection would be nonempty).\n *\n * In addition, we require that no two boxes are lineHeight (or more) apart at\n * either top or bottom, which helps protect against false positives for fonts\n * with extremely large glyph heights (e.g., with a font size of 17px, Zapfino\n * produces rects of height 58px!).\n */\nfunction areRectsOnOneLine(rects, lineHeight) {\n  var minTop = Infinity;\n  var minBottom = Infinity;\n  var maxTop = -Infinity;\n  var maxBottom = -Infinity;\n\n  for (var ii = 0; ii < rects.length; ii++) {\n    var rect = rects[ii];\n    if (rect.width === 0 || rect.width === 1) {\n      // When a range starts or ends a soft wrap, many browsers (Chrome, IE,\n      // Safari) include an empty rect on the previous or next line. When the\n      // text lies in a container whose position is not integral (e.g., from\n      // margin: auto), Safari makes these empty rects have width 1 (instead of\n      // 0). Having one-pixel-wide characters seems unlikely (and most browsers\n      // report widths in subpixel precision anyway) so it's relatively safe to\n      // skip over them.\n      continue;\n    }\n    minTop = Math.min(minTop, rect.top);\n    minBottom = Math.min(minBottom, rect.bottom);\n    maxTop = Math.max(maxTop, rect.top);\n    maxBottom = Math.max(maxBottom, rect.bottom);\n  }\n\n  return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;\n}\n\n/**\n * Return the length of a node, as used by Range offsets.\n */\nfunction getNodeLength(node) {\n  // http://www.w3.org/TR/dom/#concept-node-length\n  switch (node.nodeType) {\n    case Node.DOCUMENT_TYPE_NODE:\n      return 0;\n    case Node.TEXT_NODE:\n    case Node.PROCESSING_INSTRUCTION_NODE:\n    case Node.COMMENT_NODE:\n      return node.length;\n    default:\n      return node.childNodes.length;\n  }\n}\n\n/**\n * Given a collapsed range, move the start position backwards as far as\n * possible while the range still spans only a single line.\n */\nfunction expandRangeToStartOfLine(range) {\n  !range.collapsed ? process.env.NODE_ENV !== 'production' ? invariant(false, 'expandRangeToStartOfLine: Provided range is not collapsed.') : invariant(false) : void 0;\n  range = range.cloneRange();\n\n  var containingElement = range.startContainer;\n  if (containingElement.nodeType !== 1) {\n    containingElement = containingElement.parentNode;\n  }\n  var lineHeight = getLineHeightPx(containingElement);\n\n  // Imagine our text looks like:\n  //   <div><span>once upon a time, there was a <em>boy\n  //   who lived</em> </span><q><strong>under^ the\n  //   stairs</strong> in a small closet.</q></div>\n  // where the caret represents the cursor. First, we crawl up the tree until\n  // the range spans multiple lines (setting the start point to before\n  // \"<strong>\", then before \"<div>\"), then at each level we do a search to\n  // find the latest point which is still on a previous line. We'll find that\n  // the break point is inside the span, then inside the <em>, then in its text\n  // node child, the actual break point before \"who\".\n\n  var bestContainer = range.endContainer;\n  var bestOffset = range.endOffset;\n  range.setStart(range.startContainer, 0);\n\n  while (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n    bestContainer = range.startContainer;\n    bestOffset = range.startOffset;\n    !bestContainer.parentNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Found unexpected detached subtree when traversing.') : invariant(false) : void 0;\n    range.setStartBefore(bestContainer);\n    if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== 'inline') {\n      // The start of the line is never in a different block-level container.\n      break;\n    }\n  }\n\n  // In the above example, range now spans from \"<div>\" to \"under\",\n  // bestContainer is <div>, and bestOffset is 1 (index of <q> inside <div>)].\n  // Picking out which child to recurse into here is a special case since we\n  // don't want to check past <q> -- once we find that the final range starts\n  // in <span>, we can look at all of its children (and all of their children)\n  // to find the break point.\n\n  // At all times, (bestContainer, bestOffset) is the latest single-line start\n  // point that we know of.\n  var currentContainer = bestContainer;\n  var maxIndexToConsider = bestOffset - 1;\n\n  do {\n    var nodeValue = currentContainer.nodeValue;\n\n    for (var ii = maxIndexToConsider; ii >= 0; ii--) {\n      if (nodeValue != null && ii > 0 && UnicodeUtils.isSurrogatePair(nodeValue, ii - 1)) {\n        // We're in the middle of a surrogate pair -- skip over so we never\n        // return a range with an endpoint in the middle of a code point.\n        continue;\n      }\n\n      range.setStart(currentContainer, ii);\n      if (areRectsOnOneLine(getRangeClientRects(range), lineHeight)) {\n        bestContainer = currentContainer;\n        bestOffset = ii;\n      } else {\n        break;\n      }\n    }\n\n    if (ii === -1 || currentContainer.childNodes.length === 0) {\n      // If ii === -1, then (bestContainer, bestOffset), which is equal to\n      // (currentContainer, 0), was a single-line start point but a start\n      // point before currentContainer wasn't, so the line break seems to\n      // have occurred immediately after currentContainer's start tag\n      //\n      // If currentContainer.childNodes.length === 0, we're already at a\n      // terminal node (e.g., text node) and should return our current best.\n      break;\n    }\n\n    currentContainer = currentContainer.childNodes[ii];\n    maxIndexToConsider = getNodeLength(currentContainer);\n  } while (true);\n\n  range.setStart(bestContainer, bestOffset);\n  return range;\n}\n\nmodule.exports = expandRangeToStartOfLine;\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","UnicodeUtils","getRangeClientRects","invariant","getLineHeightPx","element","computed","getComputedStyle","div","document","createElement","style","fontFamily","fontSize","fontStyle","fontWeight","lineHeight","position","textContent","documentBody","body","NODE_ENV","appendChild","rect","getBoundingClientRect","removeChild","height","areRectsOnOneLine","rects","minTop","Infinity","minBottom","maxTop","maxBottom","ii","length","width","Math","min","top","bottom","max","getNodeLength","node","nodeType","Node","DOCUMENT_TYPE_NODE","TEXT_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","childNodes","expandRangeToStartOfLine","range","collapsed","cloneRange","containingElement","startContainer","parentNode","bestContainer","endContainer","bestOffset","endOffset","setStart","startOffset","setStartBefore","display","currentContainer","maxIndexToConsider","nodeValue","isSurrogatePair"]
}

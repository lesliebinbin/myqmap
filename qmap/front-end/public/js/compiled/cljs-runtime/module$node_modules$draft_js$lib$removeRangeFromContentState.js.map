{
"version":3,
"file":"module$node_modules$draft_js$lib$removeRangeFromContentState.js",
"lineCount":14,
"mappings":"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",
"sources":["node_modules/draft-js/lib/removeRangeFromContentState.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$draft_js$lib$removeRangeFromContentState\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule removeRangeFromContentState\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\n/**\n * Ancestors needs to be preserved when there are non selected\n * children to make sure we do not leave any orphans behind\n */\nvar getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {\n  var parents = [];\n\n  if (!blockKey) {\n    return parents;\n  }\n\n  var blockNode = blockMap.get(blockKey);\n  while (blockNode && blockNode.getParentKey()) {\n    var parentKey = blockNode.getParentKey();\n    if (parentKey) {\n      parents.push(parentKey);\n    }\n    blockNode = parentKey ? blockMap.get(parentKey) : null;\n  }\n\n  return parents;\n};\n\n/**\n * Get all next delimiter keys until we hit a root delimiter and return\n * an array of key references\n */\nvar getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {\n  var nextDelimiters = [];\n\n  if (!block) {\n    return nextDelimiters;\n  }\n\n  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);\n  while (nextDelimiter && blockMap.get(nextDelimiter)) {\n    var _block = blockMap.get(nextDelimiter);\n    nextDelimiters.push(nextDelimiter);\n\n    // we do not need to keep checking all root node siblings, just the first occurance\n    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;\n  }\n\n  return nextDelimiters;\n};\n\nvar getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  }\n\n  // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();\n\n  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {\n    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;\n  }\n\n  return nextValidSiblingKey;\n};\n\nvar getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  }\n\n  // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();\n\n  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {\n    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;\n  }\n\n  return prevValidSiblingKey;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {\n  return blockMap.withMutations(function (blocks) {\n    // update start block if its retained\n    transformBlock(startBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(startBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update endblock if its retained\n    transformBlock(endBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(endBlock, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update start block parent ancestors\n    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      return transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n\n    // update start block next - can only happen if startBlock == endBlock\n    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: startBlock.getPrevSiblingKey()\n      });\n    });\n\n    // update start block prev\n    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update end block next\n    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update end block prev\n    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: endBlock.getNextSiblingKey()\n      });\n    });\n\n    // update end block parent ancestors\n    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n\n    // update next delimiters all the way to a root delimiter\n    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {\n      return transformBlock(delimiterKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n  });\n};\n\nvar removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {\n  if (selectionState.isCollapsed()) {\n    return contentState;\n  }\n\n  var blockMap = contentState.getBlockMap();\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n\n  var startBlock = blockMap.get(startKey);\n  var endBlock = blockMap.get(endKey);\n\n  // we assume that ContentBlockNode and ContentBlocks are not mixed together\n  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode;\n\n  // used to retain blocks that should not be deleted to avoid orphan children\n  var parentAncestors = [];\n\n  if (isExperimentalTreeBlock) {\n    var endBlockchildrenKeys = endBlock.getChildKeys();\n    var endBlockAncestors = getAncestorsKeys(endKey, blockMap);\n\n    // endBlock has unselected sibblings so we can not remove its ancestors parents\n    if (endBlock.getNextSiblingKey()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors);\n    }\n\n    // endBlock has children so can not remove this block or any of its ancestors\n    if (!endBlockchildrenKeys.isEmpty()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));\n    }\n\n    // we need to retain all ancestors of the next delimiter block\n    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));\n  }\n\n  var characterList = void 0;\n\n  if (startBlock === endBlock) {\n    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);\n  } else {\n    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));\n  }\n\n  var modifiedStart = startBlock.merge({\n    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),\n    characterList: characterList\n  });\n\n  var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {\n    return k === startKey;\n  }).takeUntil(function (_, k) {\n    return k === endKey;\n  }).filter(function (_, k) {\n    return parentAncestors.indexOf(k) === -1;\n  }).concat(Map([[endKey, null]])).map(function (_, k) {\n    return k === startKey ? modifiedStart : null;\n  });\n\n  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {\n    return !!block;\n  });\n\n  if (isExperimentalTreeBlock) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: startKey,\n      anchorOffset: startOffset,\n      focusKey: startKey,\n      focusOffset: startOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\n * Maintain persistence for target list when removing characters on the\n * head and tail of the character list.\n */\nvar removeFromList = function removeFromList(targetList, startOffset, endOffset) {\n  if (startOffset === 0) {\n    while (startOffset < endOffset) {\n      targetList = targetList.shift();\n      startOffset++;\n    }\n  } else if (endOffset === targetList.count()) {\n    while (endOffset > startOffset) {\n      targetList = targetList.pop();\n      endOffset--;\n    }\n  } else {\n    var head = targetList.slice(0, startOffset);\n    var tail = targetList.slice(endOffset);\n    targetList = head.concat(tail).toList();\n  }\n  return targetList;\n};\n\nmodule.exports = removeRangeFromContentState;\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","ContentBlockNode","Immutable","getNextDelimiterBlockKey","List","Map","transformBlock","key","blockMap","func","block","get","set","getAncestorsKeys","blockKey","parents","blockNode","getParentKey","parentKey","push","getNextDelimitersBlockKeys","nextDelimiters","nextDelimiter","_block","getNextValidSibling","originalBlockMap","nextValidSiblingKey","getKey","getNextSiblingKey","getPrevValidSibling","prevValidSiblingKey","getPrevSiblingKey","updateBlockMapLinks","startBlock","endBlock","withMutations","blocks","merge","nextSibling","prevSibling","forEach","children","getChildKeys","filter","delimiterKey","removeRangeFromContentState","contentState","selectionState","isCollapsed","getBlockMap","startKey","getStartKey","startOffset","getStartOffset","endKey","getEndKey","endOffset","getEndOffset","isExperimentalTreeBlock","parentAncestors","endBlockchildrenKeys","endBlockAncestors","concat","isEmpty","characterList","removeFromList","getCharacterList","slice","modifiedStart","text","getText","newBlocks","toSeq","skipUntil","_","k","takeUntil","indexOf","map","updatedBlockMap","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","targetList","shift","count","pop","head","tail","toList"]
}

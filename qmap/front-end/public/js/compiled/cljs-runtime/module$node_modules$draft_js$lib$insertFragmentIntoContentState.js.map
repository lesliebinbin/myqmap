{
"version":3,
"file":"module$node_modules$draft_js$lib$insertFragmentIntoContentState.js",
"lineCount":13,
"mappings":"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",
"sources":["node_modules/draft-js/lib/insertFragmentIntoContentState.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$draft_js$lib$insertFragmentIntoContentState\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule insertFragmentIntoContentState\n * @format\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar insertIntoList = require('./insertIntoList');\nvar invariant = require('fbjs/lib/invariant');\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\n\nvar List = Immutable.List;\n\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    data: fragmentBlock.getData()\n  });\n\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = [];\n\n  // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    }\n\n    // update the last root block fragment\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);\n\n    // update the original target next block\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    }\n\n    // update fragment parent links\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    });\n\n    // update targetBlock parent child links\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();\n\n      // insert fragment children\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    }\n\n    // Insert fragment blocks after the head and before the tail.\n    fragment\n    // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    });\n\n    // update tail\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  }\n\n  // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","BlockMapBuilder","ContentBlockNode","Immutable","insertIntoList","invariant","randomizeBlockMapKeys","List","updateExistingBlock","contentState","selectionState","blockMap","fragmentBlock","targetKey","targetOffset","targetBlock","get","text","getText","chars","getCharacterList","finalKey","finalOffset","length","newBlock","merge","slice","characterList","data","getData","set","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","updateHead","block","fragment","headText","headCharacters","appendToHead","first","concat","type","getType","updateTail","blockSize","tailText","tailCharacters","prependToTail","last","getRootBlocks","headKey","getKey","rootBlock","rootBlocks","push","getNextSiblingKey","lastSiblingKey","updateBlockMapLinks","originalBlockMap","fragmentHeadBlock","withMutations","blockMapState","targetNextKey","targetParentKey","getParentKey","fragmentRootBlocks","lastRootFragmentBlockKey","setIn","forEach","blockKey","targetParent","originalTargetParentChildKeys","getChildKeys","targetBlockIndex","indexOf","insertionIndex","newChildrenKeysArray","toArray","splice","apply","insertFragment","isTreeBasedBlockMap","newBlockArr","fragmentSize","size","target","head","tail","getLength","shouldNotUpdateFromFragmentBlock","isEmpty","updatedBlockMap","createFromArray","insertFragmentIntoContentState","fragmentBlockMap","isCollapsed","NODE_ENV","getBlockMap","getStartKey","getStartOffset"]
}

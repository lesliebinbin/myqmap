{
"version":3,
"file":"module$node_modules$draft_js$lib$randomizeBlockMapKeys.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/draft-js/lib/randomizeBlockMapKeys.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$draft_js$lib$randomizeBlockMapKeys\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule randomizeBlockMapKeys\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar generateRandomKey = require('./generateRandomKey');\n\nvar OrderedMap = Immutable.OrderedMap;\n\n\nvar randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {\n  var newKeysRef = {};\n\n  // we keep track of root blocks in order to update subsequent sibling links\n  var lastRootBlock = void 0;\n\n  return OrderedMap(blockMap.withMutations(function (blockMapState) {\n    blockMapState.forEach(function (block, index) {\n      var oldKey = block.getKey();\n      var nextKey = block.getNextSiblingKey();\n      var prevKey = block.getPrevSiblingKey();\n      var childrenKeys = block.getChildKeys();\n      var parentKey = block.getParentKey();\n\n      // new key that we will use to build linking\n      var key = generateRandomKey();\n\n      // we will add it here to re-use it later\n      newKeysRef[oldKey] = key;\n\n      if (nextKey) {\n        var nextBlock = blockMapState.get(nextKey);\n        if (nextBlock) {\n          blockMapState.setIn([nextKey, 'prevSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'nextSibling'], null);\n        }\n      }\n\n      if (prevKey) {\n        var prevBlock = blockMapState.get(prevKey);\n        if (prevBlock) {\n          blockMapState.setIn([prevKey, 'nextSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'prevSibling'], null);\n        }\n      }\n\n      if (parentKey && blockMapState.get(parentKey)) {\n        var parentBlock = blockMapState.get(parentKey);\n        var parentChildrenList = parentBlock.getChildKeys();\n        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));\n      } else {\n        // blocks will then be treated as root block nodes\n        blockMapState.setIn([oldKey, 'parent'], null);\n\n        if (lastRootBlock) {\n          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);\n          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);\n        }\n\n        lastRootBlock = blockMapState.get(oldKey);\n      }\n\n      childrenKeys.forEach(function (childKey) {\n        var childBlock = blockMapState.get(childKey);\n        if (childBlock) {\n          blockMapState.setIn([childKey, 'parent'], key);\n        } else {\n          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {\n            return child !== childKey;\n          }));\n        }\n      });\n    });\n  }).toArray().map(function (block) {\n    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];\n  }));\n};\n\nvar randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {\n  return OrderedMap(blockMap.toArray().map(function (block) {\n    var key = generateRandomKey();\n    return [key, block.set('key', key)];\n  }));\n};\n\nvar randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n\n  if (!isTreeBasedBlockMap) {\n    return randomizeContentBlockKeys(blockMap);\n  }\n\n  return randomizeContentBlockNodeKeys(blockMap);\n};\n\nmodule.exports = randomizeBlockMapKeys;\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","ContentBlockNode","Immutable","generateRandomKey","OrderedMap","randomizeContentBlockNodeKeys","blockMap","newKeysRef","lastRootBlock","withMutations","blockMapState","forEach","block","index","oldKey","getKey","nextKey","getNextSiblingKey","prevKey","getPrevSiblingKey","childrenKeys","getChildKeys","parentKey","getParentKey","key","nextBlock","get","setIn","prevBlock","parentBlock","parentChildrenList","set","indexOf","childKey","childBlock","filter","child","toArray","map","randomizeContentBlockKeys","randomizeBlockMapKeys","isTreeBasedBlockMap","first"]
}

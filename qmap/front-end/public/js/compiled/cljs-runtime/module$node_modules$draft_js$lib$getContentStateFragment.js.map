{
"version":3,
"file":"module$node_modules$draft_js$lib$getContentStateFragment.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAe,0DAAf,CAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAgB1I,IAAIC,sBAAwBJ,OAAA,CAAQ,wDAAR,CAC5B,KAAIK,sBAAwBL,OAAA,CAAQ,wDAAR,CAE5B,KAAIM,wBAA0BA,QAASA,wBAAuB,CAACC,YAAD,CAAeC,cAAf,CAA+B,CAC3F,IAAIC,SAAWD,cAAAE,YAAA,EACf,KAAIC,YAAcH,cAAAI,eAAA,EAClB,KAAIC;AAASL,cAAAM,UAAA,EACb,KAAIC,UAAYP,cAAAQ,aAAA,EAKhB,KAAIC,2BAA6BZ,qBAAA,CAAsBE,YAAtB,CAAoCC,cAApC,CAEjC,KAAIU,SAAWD,0BAAAE,YAAA,EACf,KAAIC,UAAYF,QAAAG,OAAA,EAChB,KAAIC,WAAaF,SAAAG,QAAA,CAAkBd,QAAlB,CACjB,KAAIe,SAAWJ,SAAAG,QAAA,CAAkBV,MAAlB,CAAXW,CAAuC,CAE3C,OAAOpB,sBAAA,CAAsBc,QAAAO,MAAA,CAAeH,UAAf,CAA2BE,QAA3B,CAAAE,IAAA,CAAyC,QAAS,CAACC,KAAD,CAAQC,QAAR,CAAkB,CAC/F,IAAIC,KAAOF,KAAAG,QAAA,EACX,KAAIC,MAAQJ,KAAAK,iBAAA,EAEZ,IAAIvB,QAAJ,GAAiBI,MAAjB,CACE,MAAOc,MAAAM,MAAA,CAAY,CACjBJ,KAAMA,IAAAJ,MAAA,CAAWd,WAAX;AAAwBI,SAAxB,CADW,CAEjBmB,cAAeH,KAAAN,MAAA,CAAYd,WAAZ,CAAyBI,SAAzB,CAFE,CAAZ,CAMT,IAAIa,QAAJ,GAAiBnB,QAAjB,CACE,MAAOkB,MAAAM,MAAA,CAAY,CACjBJ,KAAMA,IAAAJ,MAAA,CAAWd,WAAX,CADW,CAEjBuB,cAAeH,KAAAN,MAAA,CAAYd,WAAZ,CAFE,CAAZ,CAMT,IAAIiB,QAAJ,GAAiBf,MAAjB,CACE,MAAOc,MAAAM,MAAA,CAAY,CACjBJ,KAAMA,IAAAJ,MAAA,CAAW,CAAX,CAAcV,SAAd,CADW,CAEjBmB,cAAeH,KAAAN,MAAA,CAAY,CAAZ,CAAeV,SAAf,CAFE,CAAZ,CAMT,OAAOY,MAzBwF,CAApE,CAAtB,CAhBoF,CA6C7F1B,OAAAC,QAAA,CAAiBI,uBAhEyH;",
"sources":["node_modules/draft-js/lib/getContentStateFragment.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$draft_js$lib$getContentStateFragment\"] = function(global,process,require,module,exports,shadow$shims) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getContentStateFragment\n * @format\n * \n */\n\n'use strict';\n\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\nvar removeEntitiesAtEdges = require('./removeEntitiesAtEdges');\n\nvar getContentStateFragment = function getContentStateFragment(contentState, selectionState) {\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n\n  // Edge entities should be stripped to ensure that we don't preserve\n  // invalid partial entities when the fragment is reused. We do, however,\n  // preserve entities that are entirely within the selection range.\n  var contentWithoutEdgeEntities = removeEntitiesAtEdges(contentState, selectionState);\n\n  var blockMap = contentWithoutEdgeEntities.getBlockMap();\n  var blockKeys = blockMap.keySeq();\n  var startIndex = blockKeys.indexOf(startKey);\n  var endIndex = blockKeys.indexOf(endKey) + 1;\n\n  return randomizeBlockMapKeys(blockMap.slice(startIndex, endIndex).map(function (block, blockKey) {\n    var text = block.getText();\n    var chars = block.getCharacterList();\n\n    if (startKey === endKey) {\n      return block.merge({\n        text: text.slice(startOffset, endOffset),\n        characterList: chars.slice(startOffset, endOffset)\n      });\n    }\n\n    if (blockKey === startKey) {\n      return block.merge({\n        text: text.slice(startOffset),\n        characterList: chars.slice(startOffset)\n      });\n    }\n\n    if (blockKey === endKey) {\n      return block.merge({\n        text: text.slice(0, endOffset),\n        characterList: chars.slice(0, endOffset)\n      });\n    }\n\n    return block;\n  }));\n};\n\nmodule.exports = getContentStateFragment;\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","randomizeBlockMapKeys","removeEntitiesAtEdges","getContentStateFragment","contentState","selectionState","startKey","getStartKey","startOffset","getStartOffset","endKey","getEndKey","endOffset","getEndOffset","contentWithoutEdgeEntities","blockMap","getBlockMap","blockKeys","keySeq","startIndex","indexOf","endIndex","slice","map","block","blockKey","text","getText","chars","getCharacterList","merge","characterList"]
}
